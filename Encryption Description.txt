If an iPhone backup is encrypted, the manifest.db file describing the backup layout will be decrypted. The "BackupKeyBag" stored in the Manifest.plist must be decrypted.
The KeyBag is decrypted after the the password has been used to generate a key. Then eached wrapped key in the keybag can be unwrapped. After this, the ManifestKey entry in the plist can be decrypted.
From here, it is easy. In the SQLite database, each file will have its metadata along with a an individual key. You can decrypt each file with this.

In code: The different types of tags that are in the KeyBag are stated.
Then, the different kind of keybags which exist are stated. Ours will obviously be a backup.
The Key types, and different protection classes are defined. These protection classes are for AFU, not really relevant for us, except they still define the key which will be used. The dictionary of protection classes is really helpful, because they are defined by numbers only in the SQLite database. For example, the protection class will be 4, which in this dictionary translates to NSFileProtectionNone. 
I don't konw what the WRAP_DEVICE and WRAP_PASSCODE data represents.

The Keybag class is called on data which is the Keybag from the Manifest. I dump it out with biplist.
The classes are initally defined, and they have a parsebinary blob function which calls loopTLVBlocks.
This function essentially loops through the blob and pulls out every four byte tag it can find. It also pulls the data associated with that tag. It knows the associated data because that is defined in a four byte stucture right after the tag.
So, binaryblob parser will go through and first check the length of the data. There is something special about if the data is 4 that they already know. Then it checks each individual tag. Line 71 gets a bit confusing. It's creating the classKeys dictionary which sems to have values for at the least CLAS and UUID. Odd.

I think what is happening here is that classKeys is a dictionary contains multiple currentClassKey values, each of which is its own dictionary. So first, it checks if there is a class key. If not, the UUID value is associated with the current tag data


Next, the unlockWithPasscode fucntion is called. It takes the provided passcode and runs it through a key derivation function multiple times using parameters from the keybag such as the salt and iterations. The passcode key is what ends up being printed on the screen.Then, in this function, it loops through all the class keys which were found in the binary blob parser and it unwraps them using the aes_unwrap function provided.
After this is the unwrapKeyForClass function. It takes the protection class and the variable name you want the key in and returns the unwrapped class key. I thought I unwrapped them all last time? This function is really important, as it seems to get the final key for decryption every time.

So, I just need to analyze more how the class keys work.

Sample email to Heather:
Hi, Mrs. Mahalik,
I took the SANS 585 class with you last year and really enjoyed it. I wanted to send you a program which would potentially be useful for the course. When we were discussing iPhone backups, I did not remember there being any open source software available to decrypt iPhone backups (I believe we used iBackup Bot or iBackup Viewer). Since it is easier to educate people how the backup methods actually work with open source software, I thought having a program that could do this would be useful.
The link below is for a GitHub repository I have with a Python script to decrypt iPhone backups. After decryption, it simply writes out the decrypted files into an output directory in the directory structure specified in the Manifest.db file. This script is very unoriginal. Most of the important elements from it I found on a post by a a Stack Exchange user named andrewdotn who heavily referenced some open source Python code from security researchers Jean-Baptiste Bedrune and Jean Sigwald. These both had broken dependencies, so I updated these and added some of my own code for the input and output.
I have tested this on Lab 4.2 from class and on my own phone backup which uses iOS 14.3 and have had no issues. I have not performed extensive validation on this, so just be aware. One odd thing to be aware of is that apparently APFS allows colon characters in file names. I have the script set currently to replace these with the characters '!-', as I had some files in one backup that contained a colon.
I hope this script may be helpful. Thanks for a great class,

Leyton Adams